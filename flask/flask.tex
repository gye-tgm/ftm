\documentclass[../main/main.tex]{subfiles}

\begin{document}

\section{Flask}  

In the following section we will see how we can quickly set up a fully
functional Flask project with the speed that the developers are
promising.

We assume that the required Python modules are already globally
installed, which is generally considered as bad practice, however,
without further ado, let's get started.

\subsection{Fundamental Setup}

\subsubsection{Project Structure}

In this section we will vaguely explain how the project should be
roughly structured.

\begin{lstlisting}
ftmatura/
  app/  [see below]
  tests/ [see below]
  app.db
  config.py
  run.py
\end{lstlisting}

The \lstinline|test/| directory should actually be very obvious,
however, it's important to note that the test files all should begin
with the same prefix, such as \lstinline|test_|, so that we can run
all tests that begin with \lstinline|test_| with one simple matching
pattern:

\begin{lstlisting}
test/
  test_base.py
  test_user.py
  test_login.py
  ...
\end{lstlisting}

In \lstinline|config.py| we will insert, as the name suggests, the
configuration of the application. 

\lstinline|run.py| is basically a script that will start the
application with or without the debug mode, depending on whether we
are using it for the production environment. 

The code that powers the software should be located inside the app/
directory:

\begin{lstlisting}
app/
  models/
  models/__init__.py
  models/model1.py
  models/model2.py
  templates/ [see below]
  static/ 
  page1/
  page2/ 
  utility1.py
  utility2.py
\end{lstlisting}

In \lstinline|templates/| we will put the code from the \textit{view}
(from MVC) component. These are basically HTML files that are fueled
by the Jinja 2 plugin, a very \textbf{powerful} plugin. 

For each subpage $i$ we will create a \lstinline|page|$_i$ module that
will contain some basic Python modules, such as \lstinline|views.py|,
\lstinline|forms.py|; files that contain the logic of the page, which
will be discussed later on. In the \lstinline|template/| directory we
will also setup a new directory for only this page; so in the end, the
template directory can take the following structure: 

\begin{lstlisting}
template/
  page1/
  page2/
  base.html
  index.html
\end{lstlisting}

This idea did not came out of the thin air, however, the developer of
Flask has unofficially suggested \cite{mitsuhiko:flask} this particular structure, which
actually makes sense on a second look. This structure is intended for
middle sized projects, such as the one that will be given in the FT
Matura. 

\subsubsection{\lstinline|run.py|}

The \lstinline|run.py| is, essentially, the main file, which is
equivalent to the main class in Java. Here we will merely call the app
with some debug flags on or off. 

\begin{lstlisting}
#!/usr/bin/env python
from app import app
# app.run(debug=True, use_debugger=False, use_reloader=False)
app.run(debug=True)
\end{lstlisting}

The one line that is commented out is vital for debugging with the
IDE, especially for PyCharm, as it turns off some additional features
that thwart the IDE from debugging with the \lstinline|pdb|. 

The file has a shebang on the first line, which means the first Python
interpreter that is found in the \lstinline|PATH| gets called. 

The file must also be given the execution rights via \lstinline|chmod u+x run.py|. 

\subsubsection{\lstinline|config.py|}
\label{sec:config.py}
The powerful and flexible \lstinline|config.py| file is Flask's
biggest asset: 

\begin{lstlisting}
from os.path import join, dirname, abspath
_cwd = dirname(abspath(__file__))

class BaseConfiguration(object):
    SECRET_KEY = this-should-be-secret'
    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + join(_cwd, 'app.db')
    SQLALCHEMY_ECHO = True

class TestConfiguration(BaseConfiguration):
    TESTING = True
    WTF_CSRF_ENABLED = False
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
\end{lstlisting}

These are some configuration variables that are important for an
appropriate setup of the SQLite database that we are going to use
throughout the exam. 

The SQLite database is also extraordinairly powerful, as it can be
used in the memory, as we can see in the \lstinline|TestConfiguration|
class. Lightweight and simple to configure, thus perfect for the exam.

\subsubsection{\lstinline|app/__init__.py|}

In this module, we are going to setup from the configuration file that
we declared in section \ref{sec:config.py}. The \lstinline|db| object
is important for the upcoming sections, as each model will be using
it implicitly, however, we'll leave it for now first. 

\begin{lstlisting}
from flask import Flask
from flask.ext.sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config.from_object('config.BaseConfiguration')

db = SQLAlchemy(app)
\end{lstlisting}

\subsection{Blueprints}

Blueprints are essentially sets of operations that will be executed,
if they are registered into the \lstinline|app|. Here, we will use a
couple of them, as they increase the degree of modularity and
flexibility. To be more specific, we will use for each new page a
single blueprint. 

The registration will be done in the \lstinline|app/__init__.py|
file. Note that we can also specify the \lstinline|url_prefix|: 

\begin{lstlisting}
from app.users.views import mod as user_mod
app.register_blueprint(user_mod, url_prefix='/home')
\end{lstlisting}

While the \lstinline|app/users/views.py| could have the following
content:

\begin{lstlisting}
from flask import Blueprint, render_tmplate

mod = Blueprint('user', __name__, template_folder='templates')
@mod.route('/')
def index():
    return render_template('user/index.html')
\end{lstlisting}

To sum it up a little bit: for every page, we create a single module
inside the \lstinline|app/| module, and create a \lstinline|views.py|
file, in which we will declare the blueprints. 

Note that we can register the blueprints under several names, and not
just only a single one. 

While developing, it might happen that the \lstinline|url_prefix|
should be changed, due to an arbitrary reason, then we merely change
the \lstinline|url_prefix|, instead of every
\lstinline|@mod.route('/path/to/this/bp')| to something else, which is
indeed very convenient.


% \bibliographystyle{ieeetr}
% \ifcsdef{mainfile}{}{\bibliography{../primary}}

\end{document}