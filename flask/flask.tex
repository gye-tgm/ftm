\documentclass[../main/main.tex]{subfiles}

\begin{document}

\section{Flask}  

In the following section we will see how we can quickly set up a fully
functional Flask project with the speed that the developers are
promising.

We assume that the required Python modules are already globally
installed, which is generally considered as bad practice, however,
without further ado, let's get started.

\subsection{Fundamental Setup}

\subsubsection{Project Structure}

In this section we will vaguely explain how the project should be
roughly structured.

\begin{lstlisting}
ftmatura/
  app/  [see below]
  tests/ [see below]
  app.db
  config.py
  run.py
\end{lstlisting}

The \lstinline|test/| directory should actually be very obvious,
however, it's important to note that the test files all should begin
with the same prefix, such as \lstinline|test_|, so that we can run
all tests that begin with \lstinline|test_| with one simple matching
pattern \lstinline|test_*|: 

\begin{lstlisting}
test/
  test_base.py
  test_user.py
  test_login.py
  ...
\end{lstlisting}

In \lstinline|config.py| we will insert, as the name suggests, the
configuration of the application. 

\lstinline|run.py| is basically a script that will start the
application with or without the debug mode, depending on whether we
are using it for the production environment. 

The code that powers the software should be located inside the app/
directory:

\begin{lstlisting}
app/
  models/
  models/__init__.py
  models/model1.py
  models/model2.py
  templates/ [see below]
  static/ 
  page1/
  page2/ 
  utility1.py
  utility2.py
\end{lstlisting}

In \lstinline|templates/| we will put the code from the \textit{view}
(from MVC) component. These are basically HTML files that are fueled
by the Jinja 2 plugin, a very \textbf{powerful} plugin. 

For each subpage $i$ we will create a \lstinline|page|$_i$ module that
will contain some basic Python modules, such as \lstinline|views.py|,
\lstinline|forms.py|; files that contain the logic of the page, which
will be discussed later on. In the \lstinline|template/| directory we
will also setup a new directory for only this page; so in the end, the
template directory can take the following structure: 

\begin{lstlisting}
template/
  page1/
  page2/
  base.html
  index.html
\end{lstlisting}

This idea did not came out of the thin air, however, the developer of
Flask has unofficially suggested \cite{mitsuhiko:flask} this particular structure, which
actually makes sense on a second look. This structure is intended for
middle sized projects, such as the one that will be given in the FT
Matura. 

\subsubsection{\lstinline|run.py|}

The \lstinline|run.py| is, essentially, the main file, which is
equivalent to the main class in Java. Here we will merely call the app
with some debug flags on or off. 

\begin{lstlisting}[caption=run.py, label=lst:run.py]
#!/usr/bin/env python
from app import app
# app.run(debug=True, use_debugger=False, use_reloader=False)
app.run(debug=True)
\end{lstlisting}

The one line that is commented out is vital for debugging with the
IDE, especially for PyCharm, as it turns off some additional features
that thwart the IDE from debugging with the \lstinline|pdb|. 

The file has a shebang on the first line, which means the first Python
interpreter that is found in the \lstinline|PATH| gets called. 

The file must also be given the execution rights via \lstinline|chmod u+x run.py|. 

\subsubsection{\lstinline|config.py|}
\label{sec:config.py}
The powerful and flexible \lstinline|config.py| file is Flask's
biggest asset: 

\begin{lstlisting}[caption=config.py, label=lst:config.py]
from os.path import join, dirname, abspath
_cwd = dirname(abspath(__file__))

class BaseConfiguration(object):
    SECRET_KEY = this-should-be-secret'
    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + join(_cwd, 'app.db')
    SQLALCHEMY_ECHO = True

class TestConfiguration(BaseConfiguration):
    TESTING = True
    WTF_CSRF_ENABLED = False
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
\end{lstlisting}

These are some configuration variables that are important for an
appropriate setup of the SQLite database that we are going to use
throughout the exam. 

The SQLite database is also extraordinairly powerful, as it can be
used in the memory, as we can see in the \lstinline|TestConfiguration|
class. Lightweight and simple to configure, thus perfect for the exam.

\subsubsection{\lstinline|app/__init__.py|}

In this module, we are going to setup from the configuration file that
we declared in section \ref{sec:config.py}. The \lstinline|db| object
is important for the upcoming sections, as each model will be using
it implicitly, however, we'll leave it for now first. 

\begin{lstlisting}[caption=app/\_\_init\_\_.py, label=lst:app/init.py]
from flask import Flask
from flask.ext.sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config.from_object('config.BaseConfiguration')

db = SQLAlchemy(app)
\end{lstlisting}

\subsection{Blueprints}

Blueprints are essentially sets of operations that will be executed,
if they are registered into the \lstinline|app|. Here, we will use a
couple of them, as they increase the degree of modularity and
flexibility. To be more specific, we will use for each new page a
single blueprint. 

The registration will be done in the \lstinline|app/__init__.py|
file. Note that we can also specify the \lstinline|url_prefix|: 

\begin{lstlisting}
from app.users.views import mod as user_mod
app.register_blueprint(user_mod, url_prefix='/home')
\end{lstlisting}

While the \lstinline|app/users/views.py| could have the following
content:

\begin{lstlisting}
from flask import Blueprint, render_tmplate

mod = Blueprint('user', __name__, template_folder='templates')
@mod.route('/')
def index():
    return render_template('user/index.html')
\end{lstlisting}

To sum it up a little bit: for every page, we create a single module
inside the \lstinline|app/| module, and create a \lstinline|views.py|
file, in which we will declare the blueprints. 

Note that we can register the blueprints under several names, and not
just only a single one. 

While developing, it might happen that the \lstinline|url_prefix|
should be changed, due to an arbitrary reason, then we merely change
the \lstinline|url_prefix|, instead of every
\lstinline|@mod.route('/path/to/this/bp')| to something else, which is
indeed very convenient.

The first parameter in the \lstinline|Blueprint| constructor just
states the names under which the blueprint can be accessed. Should the
name be \lstinline|user|, then we can for instance use the handy
\lstinline|url_for('user.index')| function to get the corresponding
link to the \lstinline|index()| function of this blueprint. 

However, we must take care that there are no names collisions, which
means that we can't just register multiple non-identical blueprints
under the same name. 

% TODO: more more more!

\subsection{The Model Classes (+Relationships)}

\subsubsection{Simple Declaration}
In this section we want to briefly discuss how to implement a single
model class via the \lstinline|Flask-SQLAlchemy| module. 

We first declare a helper class that we will put into
\lstinline|app/data.py|: 

\begin{lstlisting}[caption=app/data.py, label=lst:data.py]
from app import db

class CRUDMixin(object):
    """
    Inheriting this class eliminates common code for the fundamental CRUD commands.
    """
    __table_args__ = {'extend_existing': True}

    id = db.Column(db.Integer, primary_key=True)

    @classmethod
    def create(cls, commit=True, **kwargs):
        instance = cls(**kwargs)
        return instance.save(commit=commit)

    @classmethod
    def get(cls, id):
        return cls.query.get(id)

    @classmethod
    def get_or_404(cls, id):
        return cls.query.get_or_404(id)

    def update(self, commit=True, **kwargs):
        for attr, value in kwargs.iteritems():
            setattr(self, attr, value)
        return commit and self.save() or self

    def save(self, commit=True):
        db.session.add(self)
        if commit:
            db.session.commit()
        return self

    def delete(self, commit=True):
        db.session.delete(self)
        return commit and db.session.commit()  
\end{lstlisting}

Basically, it just reduces a few lines for each CRUD command, however,
on a long term, this will reduce the number of code lines, thus the
developing time, proportionally. 

As we know from SQLAlchemy, every object that we need to insert into
the database has to be first added from the \lstinline|session|
object, and then the \lstinline|session| object has to commit the
session. This might get tedious, especially if 5 hours test timer is
running in the background.

Additionally, it contains an integer, called \lstinline|id|, as a
primary key, which happens to be the case in a vast majority of the
model classes.

Let's consider the implementation of the following \lstinline|User|
class: 

\begin{lstlisting}[caption=app/models/user.py, label=lst:user.py]
from app.data import CRUDMixin, db
from app.models import SocialMediaAccount
from app.models.post import Post
from flask.ext.login import UserMixin

ROLE_USER = 0
ROLE_ADMIN = 1

class User(db.Model, UserMixin, CRUDMixin):
    __tablename__ = 'user'

    username = db.Column(db.String, unique=True)
    password = db.Column(db.String)
    role = db.Column(db.Integer, default=ROLE_USER)

    accounts = db.relationship(SocialMediaAccount, backref='user', lazy='dynamic')
    posts = db.relationship(Post, backref='user', lazy='dynamic')

    def is_authenticated(self):
        return True

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def get_id(self):
        return str(self.id)

    def is_valid_password(self, password):
        # normally you would compare the hash here
        return self.password == password

    def __repr__(self):
        return "<User #{:d}>".format(self.id)
\end{lstlisting}

We do not consider \lstinline|UserMixin|, which is a class used for
authentication, as we will rather focus on the so famous
\lstinline|db.Model| and the \lstinline|CRUDMixin| class that we have
just declared.

There are some crucial facts that must be considered during the
implementation of the model classes:

\begin{itemize}
  \item \lstinline|__tablename__| is the tablename that we will also
    find in the database. Having this attribute is
    \textbf{obligatory}. 
  \item Normally, every table must also have a \textbf{primary key}, however,
    by inheriting from the convenient \lstinline|CRUDMixin| class, we
    also inherit a very common \lstinline|id| primary key. 
  \item Each model class that inherits from \lstinline|db.Model|
    is essentially just a table in the database. 
\end{itemize}

Details on how to have relationships such as inheritance, one-to-many,
many-to-many, etc., will be considered in Sections
\ref{sec:relationships}, \ref{sec:onetomany}, \ref{sec:manytomany},
\ref{sec:inheritance}. (Hint: CTRL+F might come handy) 

We will come back to this code later on, as there are some undiscussed
methods which are more useful for the authentication and authorization
part, as seen in section \ref{sec:auth}.

Nevertheless, the columns, as seen in the docs of the
\lstinline|Flas-SQLAlchemy| \cite{mitsuhiko:declare_models}, can have
the following datatypes: 

\begin{tabular}{ | l | l | l | } \\ \hline
Integer & an integer & \lstinline|db.Integer| \\ \hline
String (size) & a string with a maximum length &  \lstinline|db.String(42)|\\ \hline
Text & some longer unicode text &  \lstinline|db.Text|  \\ \hline
DateTime & date and time expressed as Python datetime object. & \lstinline|db.DateTime|\\ \hline
Float & stores floating point values & \lstinline|db.Float| \\ \hline
Boolean & stores a boolean value & \lstinline|db.Boolean| \\ \hline
Pickle & Typestores a pickled Python object &  \lstinline|db.Pickle| \\ \hline
LargeBinary & stores large arbitrary binary data &  \lstinline|db.LargeBinary|\\ \hline
\end{tabular}


\subsubsection{Relationships}
\label{sec:relationships}

Relationships are expressed with \lstinline|relationship()|. The
first paramater can either be the class or just the (string) name of the
class \cite{mitsuhiko:declare_models}, since one might want to declare
the class with the foreign key at an uncertain time in the future. 

Let's jump right into the more concrete associations in the following
sections. 

\subsubsection{One-To-Many}
\label{sec:onetomany}

If we consider the one single line from \ref{lst:user.py}:

\begin{lstlisting}
  posts = db.relationship(Post, backref='user', lazy='dynamic')  
\end{lstlisting}

Then we can obviously spot the relationship that the user can have
multiple posts. 

The corresponding \lstinline|Post| class follows: 

\begin{lstlisting}[caption=app/models/post.py, label=post.py]
from app import db
from app.data import CRUDMixin

class Post(db.Model, CRUDMixin):
    __tablename__ = 'post'

    content = db.Column(db.String)
    time = db.Column(db.Date)

    # vvv HERE vvv
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
   #  ^^^ HERE ^^^
\end{lstlisting}

Notice that the post class, which is also the class on the
\textit{many} side, must have a foreign key of the corresponding user
class.

\subsubsection{Many-To-Many (Association Object)}
\label{sec:manytomany}

\begin{lstlisting}
from app import db
from app.data import CRUDMixin
from app.models import User

class Follow(db.Model, CRUDMixin):
    """
    a follows b
    """
    __tablename__ = 'follow'
    a_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    b_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)

    following_since = db.Column(db.Date, nullable=False, default=db.func.now())

    # issue: http://stackoverflow.com/questions/18807322/sqlalchemy-foreign-key-relationship-attributes
    a = db.relationship(User, foreign_keys="Follow.a_id")
    b = db.relationship(User, foreign_keys="Follow.b_id")
\end{lstlisting}

\subsubsection{Inheritance}
\label{sec:inheritance}

Some exampolos: 

\begin{lstlisting}
from app import db
from app.data import CRUDMixin

class SocialMediaAccount(db.Model, CRUDMixin):
    __tablename__ = 'smaccount'
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    discriminator = db.Column(db.Integer)
    __mapper_args__ = {'polymorphic_on': discriminator}  
\end{lstlisting}

\begin{lstlisting}
from app import db
from app.models import SocialMediaAccount

class FacebookAccount(SocialMediaAccount):
    __tablename__ = 'fbaccount'
    __mapper_args__ = {'polymorphic_identity': 'fb_account'}

    id = db.Column(db.Integer, db.ForeignKey('smaccount.id'), primary_key=True)
    url = db.Column(db.String)
\end{lstlisting}


\begin{lstlisting}
from app import db
from app.models import SocialMediaAccount

class TwitterAccount(SocialMediaAccount):
    __tablename__ = 'twitteraccount'
    __mapper_args__ = {'polymorphic_identity': 'tw_account'}

    id = db.Column(db.Integer, db.ForeignKey('smaccount.id'), primary_key=True)
    username = db.Column(db.String)  
\end{lstlisting}

\subsection{Authentication and Authorization (Login)}
\label{sec:auth}

In this section we will discuss how to setup a simple login system
with the \lstinline|Flask-Login| module. 

The code of the user is already seen in Listing \ref{lst:user.py}. 

% \bibliographystyle{ieeetr}
% \ifcsdef{mainfile}{}{\bibliography{../primary}}

\end{document}